

# 通信领域

## 1.1 自动化发邮件

```python
import smtplib
from email.mime.text import MIMEText


def send_email(title: str, content: str, receivers: list[str]):
    """
    发邮件的 demo
    使用的是 163.com 邮箱
    参考：https://zhuanlan.zhihu.com/p/24180606
    :param title: 邮件标题
    :param content: 邮件正文
    :param receivers: 邮件接受方邮箱地址，注意需要[]包裹，这意味着你可以写多个邮件地址群发
    :return:
    """
    # 设置服务器所需信息
    # 163 邮箱服务器地址
    mail_host = 'smtp.163.com'
    # 163 用户名
    mail_user = '13619088487'
    # 密码(部分邮箱为授权码)
    # todo：上面有参考的网址
    mail_pass = ''
    # 邮件发送方邮箱地址
    sender = '13619088487@163.com'

    # 设置email信息
    # 邮件内容设置
    message = MIMEText(content, 'plain', 'utf-8')
    # 邮件主题
    message['Subject'] = title
    # 发送方信息
    message['From'] = sender
    # 接受方信息
    message['To'] = receivers[0]

    # 登录并发送邮件
    try:
        smtpObj = smtplib.SMTP()
        # 连接到服务器
        smtpObj.connect(mail_host, 25)
        # 登录到服务器
        smtpObj.login(mail_user, mail_pass)
        # 发送
        smtpObj.sendmail(
            sender, receivers, message.as_string())
        # 退出
        smtpObj.quit()
        # print('success')
    except smtplib.SMTPException as e:
        print('error', e)  # 打印错误
```

# Word 自动化





# Excel自动化

## 1 openpyxl

> 注意：该库是针对于操作或处理```Excel```文件，而不是处理数据！
>
> 例如，更改```Excel```中字体字号，背景颜色，图片大小，插入```Excel```公式等，是应该选择该库的。而处理保存在```Excel```中的数据（重点是**处理数据**），即表单样式的数据，应当选择```pandas```模块。
>
> 哪怕是读写```Excel```文件数据，也应当使用```pandas```模块的```read_excel()```和```to_excel()```函数，使代码更加简洁。只有涉及到对```Excel```**文件内的处理**，才应当考虑使用该模块。

### 1.1 简介

- openpyxl - 读/写 Excel 2010 xlsx/xlsm 文件的 Python 库
- [官方文档](https://openpyxl-chinese-docs.readthedocs.io/zh_CN/latest/index.html)
- 由于我之前该库的入门知识，所以本部分仅记录我**现在学的进阶的知识点**。
- 入门可参考这本书：Python编程快速上手—让繁琐工作自动化(Automate the boring stuff with python) (Al, Sweigart 王海鹏) (z-lib.org)

### 1.2 图片处理

自己开个```Excel```，随便丢张图片进去...

- 获得图片对象

  ```python
  workbook = load_workbook(r'C:\Users\lenovo\Desktop\1.xlsx')
  worksheet = workbook.active
  for image in worksheet._images:
      print(image)  # openpyxl.drawing.image.Image
  ```

- 添加图片

  ```python
  from openpyxl.drawing.image import Image
  
  image = Image(r'logo.png')
  worksheet.add_image(image)
  ```

  ```add_image()```函数源码如下。```anchor```参数在此处，可传一个字符串，表示插入的这张图片的左上角位于哪一个单元格，例如```anchor='A7'```。当然也可以传入其他参数，会```anchor```部分细说。

  ```python
  def add_image(self, img, anchor=None):
      """
      Add an image to the sheet.
      Optionally provide a cell for the top-left anchor
      """
      if anchor is not None:
          img.anchor = anchor
      self._images.append(img)
  ```

- 图片对象

  ```openpyxl.drawing.image.Image```，即```add_image()```函数的第一个参数。

  - 属性

    - ```anchor```：会在后面细说。如果是一个字符串，表示这张图片的左上角位于哪一个单元格。

    - ```width```和```height```：图片大小，单位为像素。底层由```Pillow```模块读取图像。

  - 方法

    - ```_data()```：返回图片的二进制数据。
    - ```path()```：返回图片在压缩包的路径。（本质上```Excel```是一个压缩包，可改后缀为```.zip```感受。）

  ```python
  for image in worksheet._images:
      print(image.path)  # /xl/media/image1.png
      with open('pic.jpg', mode='wb') as f:
          f.write(image._data())
  ```

- ```anchor```对象

  > 参考：如何用python向excel中以嵌入单元格的方式插入图片？ - 中等难度的贪吃蛇的回答 - 知乎 https://www.zhihu.com/question/545128505/answer/2592296060

  为了解决插入的图片是有这个属性，才学了```anchor```对象

  ![image-20230313171042701](assets/image-20230313171042701.png)

  方法```openpyxl.drawing.spreadsheet_drawing.AnchorMarker()```用于标记一个**锚点**，方法```openpyxl.drawing.spreadsheet_drawing.TwoCellAnchor()```用于将两个锚点组合成一个**锚点对**，将图片的`anchor`属性设置为这个锚点对，插入图片时即可获得上述效果。

  其中，```AnchorMarker()```方法接收四个参数，分别是列号、列偏移、行号、行偏移。列号与行号表示锚点所在的单元格坐标，从0开始。两个偏移量则表示锚点相对于单元格左上角的偏移量。

  例如，以下代码表示锚点位于`A1`单元格的左上角：

  ```python
  AnchorMarker(0, 0, 0, 0)
  ```

  以下代码表示锚点位于`C5`单元格的左上角：

  ```python3
  AnchorMarker(2, 0, 4, 0)
  ```

  偏移量为正表示锚点向右/向下偏移，为负则是向左/向上。它的单位非常小（因此数值要设得很大才能看到效果，这可能是为了即便表格缩放至最大，也能精细地调整对象的位置）。以下代码表示锚点位于`A1`单元格离左上角有些许距离（向右下方偏移）的位置：

  ```python3
  AnchorMarker(0, 50000, 0, 50000)
  ```

  以下代码表示锚点位于`C5`单元格向左上方有些许偏移的位置：

  ```python3
  AnchorMarker(2, -50000, 4, -50000)
  ```

  注意此时这个锚点落在了`B4`单元格内，但它**所属的单元格仍然是`C5`**。

  `TwoCellAnchor()`方法接收三个参数，第一个参数需要字符串形式的**描述**，设置锚点对时这个参数应设为`'twoCell'`。第二和第三个参数则分别是两个由`AnchorMarker()`方法生成的锚点。

  以下代码将上述两个锚点组合成锚点对放进变量`anchor`：

  ```python3
  _from = AnchorMarker(0, 50000, 0, 50000)
  to = AnchorMarker(2, -50000, 4, -50000)
  anchor = TwoCellAnchor('twoCell', _from, to)
  ```

  所以，下面这个捏：

  ```py
  from openpyxl import load_workbook
  from openpyxl.drawing.image import Image
  from openpyxl.drawing.spreadsheet_drawing import TwoCellAnchor, AnchorMarker
  
  wb = load_workbook(r'C:\Users\lenovo\Desktop\11.xlsx')
  worksheet = wb.active
  
  # 设置图片锚点和大小
  _from = AnchorMarker(col=4, colOff=0, row=4, rowOff=0)
  to = AnchorMarker(col=5, colOff=47543, row=6, rowOff=154242)
  anchor = TwoCellAnchor('twoCell', _from, to)
  
  image = Image(r'pic.jpg')
  image.anchor = anchor
  image.width, image.height = 100, 100
  
  # 将图片插入到目标Excel文件中
  worksheet.add_image(image)
  
  wb.save(r'C:\Users\lenovo\Desktop\110.xlsx')
  ```

  - [图片单元格居中](https://blog.csdn.net/chenliang1038/article/details/121659981)
  
  ```python
  import openpyxl
  from openpyxl.styles import Alignment, Font, PatternFill, Border
  import logging
  from openpyxl.cell.cell import get_column_letter
  from openpyxl.drawing.image import Image
  from openpyxl.drawing.xdr import XDRPoint2D, XDRPositiveSize2D
  from openpyxl.drawing.spreadsheet_drawing import AnchorMarker, OneCellAnchor
  from openpyxl.utils.units import pixels_to_EMU
  
  logger = logging.getLogger('error')
  
  
  def insert_image(worksheet, start_row, start_col, height, image_url, image_size=None):
      """
      # 计算图片大小 img_size[0]=180; img_size[1]=80
      :param worksheet:  openpyxl.Worksheet对象
      :param start_row:   # 哪一行开始
      :param start_col:   # 那一列
      :param height:      # 合并了多少行
      :param image_url:   # 图片路径
      :param image_size:  # 在excel中图片显示的最大宽高
      :return:  # None
      """
      try:
          # 像素转换为EMU
          p2e = pixels_to_EMU
          # 获取图片
          img = Image(image_url)
          # 计算原图片的宽高比例
          per = img.width / img.height
          # 固定图片高为80，通过（原图片宽高比例）计算出宽为多少
          shr_image_width = image_size[1] * per  # w:h     shr_image_width:80
          # 计算出的宽高
          img_size = shr_image_width, image_size[1]
          # 如果图片的宽大于160，就以宽为固定边为160，计算高
          if shr_image_width > image_size[0]:
              shr_image_height = image_size[0] / per  # w:h     150:shr_image_hieght
              # 计算出实际的宽高
              img_size = image_size[0], shr_image_height
          # 把原图片固定为实际的宽高
          img.height, img.width = img_size
          # 计算出图片在excel中位置，是图片的大小
          size = XDRPositiveSize2D(p2e(img.height), p2e(img.width))
          # 设置图片在左右居中
          col_letter = get_column_letter(start_col)  # 定位哪一列
          width = worksheet.column_dimensions[col_letter].width
          _col = int((width * 8 - img.height) / 2)   # 左右偏移量，左右相等就居中
          # 设置图片上下居中（因为行方向合并了多个单元格）
          h2_lst = []   # 每个单元格累计的高度
          acc_height = 0
          for row in range(start_row, start_row + height):
              h = worksheet.row_dimensions[row].height
              if not h:
                  worksheet.row_dimensions[row].height = 15
                  acc_height += 15
                  h2_lst.append(int(acc_height * 20 / 15))
              else:
                  acc_height += h
                  h2_lst.append(int(acc_height * 20 / 15))
          h2_lst.insert(0, 0)   # 从0开始
          top = int((h2_lst[-1] - img.width) / 2)  # 距离顶部的距离
          pos = []
          for nid, ele in enumerate(h2_lst):
              if top < ele:
                  pos.append((nid, top))
          row = start_row + pos[0][0] - 1    # 定位哪一行
          index = pos[0][0]
          _row = pos[0][1] - h2_lst[index]   # 上下偏移量（相对于这个单元格）
          # 相对于单元格内的(x,y,top,left)偏移量
          marker = AnchorMarker(col=start_col - 1, colOff=p2e(_col), row=row, rowOff=p2e(_row))
          img.anchor = OneCellAnchor(_from=marker, ext=size)
          worksheet.add_image(img)
      except Exception as e:
          logger.error(e)
          pass
  
  
  if __name__ == '__main__':
      wb = openpyxl.Workbook()
      ws = wb.active
      ws.merge_cells(start_row=5, end_row=14, start_column=5, end_column=5)
      col_letter = get_column_letter(5)  # 定位哪一列
      ws.column_dimensions[col_letter].width = 25
      insert_image(ws, 5, 5, 9, '111.jpg', (160, 80))
      wb.save('xxx.xlsx')
  ```
  
  













