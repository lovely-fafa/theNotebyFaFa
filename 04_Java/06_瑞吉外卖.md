2023年4月25日14:23 虔诚地打开

<img src="assets/image-20230425142323516.png" alt="image-20230425142323516" style="zoom:25%;" />

# 瑞吉外卖

## 前置知识

- Java基础知识
- Java Web
- MySQL
- Spring BootSSM（Spring、Spring MVC、MyBatis）
- Maven

## 学习收获

- 了解企业项目开发的完整流程，增长开发经验
- 了解需求分析的过程，提高分析和设计能力
- 对所学技术进行灵活应用，提高编码能力
- 解决各种异常情况，提高代码调试能力

# day 01

## 1 软件开发整体介绍

### 1.1 软件开发流程

- 需求分析

  产品原型、需求规格说明书

- 设计

  产品文档、UI 界面设计、概要设计、详细设计、数据库设计

- 编码

  项目代码、单元测试

- 测试

  测试用例、测试报告

- 上线运维

  软件环境安装、配置

### 1.2 角色分工

- 项目经理：对整个项目负责，任务分配、把控进度
- 产品经理：进行需求调研，输出需求调研文档、产品原型等
- UI 设计师：根据产品原型输出界面效果图
- 架构师：项目整体架构设计、技术选型等
- 开发工程师：代码实现
- 测试工程师：编写测试用例，输出测试报告运维工程师:软件环境搭建、项目上线

### 1.3 软件环境

- 开发环境（development）：开发人员在开发阶段使用的环境，一般外部用户无法访问
- 测试环境（testing）：专门给测试人员使用的环境，用于测试项目，一般外部用户无法访问
- 生产环境（production）：即线上环境，正式提供对外服务的环境

## 2 瑞吉外卖项目介绍

### 2.1 项目介绍

本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括系统管理后台和移动端应用两部分其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的菜品、套餐、订单等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等。

本项目共分为 3 期进行开发

- 第一期主要实现基本需求，其中移动端应用通过 H5 实现，用户可以通过手机浏览器访问
- 第二期主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便
- 第三期主要针对系统进行优化升级，提高系统的访问性能。

### 2.2 产品原型展示

产品原型，就是一款产品成型之前的一个简单的框架，就是将页面的排版布局展现出来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的功能。

产品原型主要用于展示项目的功能，并不是最终的页面效果。

### 2.3 技术选型

![image-20230425145949134](assets/image-20230425145949134.png)

### 2.4 功能架构

- 移动端前台（H5、微信小程序）
  - 手机号登录
  - 菜品规格
  - 微信登录
  - 购物车
  - 地址管理
  - 下单
  - 历史订单
  - 菜品浏览
- 系统管理后台
  - 分类管理
  - 员工登录
  - 菜品管理
  - 员工退出
  - 套餐管理
  - 员工管理
  - 菜品口味管理
  - 订单管理

### 2.5 角色

- 后台系统管理员：登录后台管理系统，拥有后台系统中的所有操作权限
- 后台系统普通员工：登录后台管理系统，对菜品、套餐、订单等进行管理
- C端用户：登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等

## 3 开发环境搭建

### 3.1 数据库

```sql
CREATE DATABASE reggie CHARACTER SET utf8mb4;
```

|       表名        | 说明             |
| :---------------: | ---------------- |
|    `employee`     | 员工表           |
|    `category`     | 菜品和套餐分类表 |
|      `dish`       | 菜品表           |
|     `setmeal`     | 套餐表           |
|  `setmeal_dish`   | 套餐菜品关系表   |
| `dishdish_flavor` | 菜品口味关系表   |
|      `user`       | 用户表（C端）    |
|  `address_book`   | 地址簿表         |
|  `shopping_cart`  | 购物车表         |
|     `orders`      | 订单表           |
|  `order_detail`   | 订单明细表       |

### 3.2 Maven

### 3.3 启动类与相关配置

将静态资源`backend`与`front`放置到`resources`文件夹。由于 SpringBoot 默认的静态文件是在`static`或`template`文件夹，所以创建配置类进行配置。

```java
@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 设置静态资源映射
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        log.info("开始静态资源映射...");
        // classpath: 指的是 resources 文件夹
        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");  // 斜线不要漏了...
        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");
    }
}
```

## 4 后台登录功能开发

### 4.2 代码开发

1. 将页面提交的密码`password`进行 md5 加密处理
2. 根据页面提交的用户名`username`查询数据库
3. 如果没有查询到则返回登录失败结果
4. 密码比对，如果不一致则返回登录失败结果
5. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果
6. 登录成功，将员工`id`存入`Session`并返回登录成功结果

![image-20230427105348146](assets/image-20230427105348146.png)

### 4.3 功能测试

测啊测，测测测...

## 5 后台退出功能开发

- 用户点击页面中退出按钮，发送请求，请求地址为`/employee/logout`，请求方式为POST
- 我们只需要在`Controller`中创建对应的处理方法即可，具体的处理逻辑
  - 清理`Session`中的用户`id`
  - 返回结果

# day 02 员工管理业务

## 1 完善登录功能

### 1.1 需求分析

前面我们已经完成了后台系统的员工登录功能开发，但是还存在一个问题：用户如果不登录，直接访问系统首页面，照样可以正常访问。这种设计并不合理，我们希望看到的效果应该是，只有登录成功后才可以访问系统中的页面，如果没有登录则跳转到登录页面。

那么，具体应该怎么实现呢？答案就是使用过滤器或者拦截器，在过滤器或者拦截器中判断用户是否已经完成登录，如果没有登录则跳转到登录页面，

### 1.2 代码实现

1. 创建自定义过滤器`LoginCheckFilter`
2. 在启动类上加入注解`@ServletComponentScan`
3. 完善过滤器的处理逻辑

过滤器具体的处理逻辑如下：

1. 获取本次请求的 URL
2. 判断本次请求是否需要处理
3. 如果不需要处理，则直接放行
4. 判断登录状态，如果已登录，则直接放行
5. 如果未登录则返回未登录结果

![image-20230503115602088](assets/image-20230503115602088.png)

```java
package com.itheima.reggie.filter;

import com.alibaba.fastjson.JSON;
import com.itheima.reggie.common.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 检查用户是否完成登录
 */
@Slf4j
@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    // 路径匹配器 支持通配符
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        // 1. 获取本次请求的 URL
        String requestURI = request.getRequestURI();
        log.info("拦截到请求：{}", requestURI);

        // 2. 判断本次请求是否需要处理
        // 定义不需要处理的请求路径
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "/front/**",
        };
        boolean check = check(urls, requestURI);

        // 3. 如果不需要处理，则直接放行
        if (check) {
            log.info("本次请求不需要处理：{}", requestURI);
            filterChain.doFilter(request, response);
            return;
        }

        // 4. 判断登录状态，如果已登录，则直接放行
        Object attribute = request.getSession().getAttribute("employee");
        // log.info("\n\n\n{}\n\n\n{}\n\n\n", attribute, attribute.toString());
        if (attribute != null) {
            log.info("用户已登录，用户 id 为 {}", attribute);

            filterChain.doFilter(request, response);
            return;
        }

        // 5. 如果未登录则返回未登录结果
        response.getWriter().write(JSON.toJSONString(Result.error("NOTLOGIN")));
        log.info("用户未登录");
        return;
    }

    /**
     * 路径匹配 判断本次请求是否需要放行
     * @param urls
     * @param requestURI
     * @return true: 放行 false: 需要校验是否登录
     */
    public boolean check(String[] urls, String requestURI) {
        for (String url : urls) {
            boolean match = PATH_MATCHER.match(url, requestURI);
            if (match) {
                return true;
            }
        }
        return false;
    }
}
```

## 2 新增员工

### 2.1 需求分析

1. 页面发送`ajax`请求，将新增员工页面中输入的数据以`json`的形式提交到服务端
2. 服务端`Controller`接收页面提交的数据并调用`Service`将数据进行保存
3. `Service`调用`Mapper`操作数据库，保存数据

前面的程序还存在一个问题，就是当我们在新增员工时输入的账号已经存在，由于`emplovee`表中对该字段加入了唯一约束，此时程序会抛出异常：

```java
java.sql.SQLIntegrityConstraintViolationException: Duplicate entry 'fafa' for key 'employee.idx_username'
```

### 2.2 代码实现

```java
/**
 * 新增员工
 * @param employee
 * @return
 */
@PostMapping
public Result<String> save(@RequestBody Employee employee, HttpServletRequest request) {
    log.info("新增员工，员工信息：{}", employee);

    // 初始密码
    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));
    employee.setCreateTime(LocalDateTime.now());
    employee.setUpdateTime(LocalDateTime.now());
    employee.setCreateUser((Long) request.getSession().getAttribute("employee"));
    employee.setUpdateUser((Long) request.getSession().getAttribute("employee"));

    employeeService.save(employee);

    return Result.success("添加成功");
}
```

### 2.3 全局异常处理器

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常处理器
 */
@ControllerAdvice(annotations = {RestController.class, Controller.class})  // 捕获加了这些注解的类所抛出的异常
@ResponseBody
@Slf4j
public class GlobalExceptionHandle {

    /**
     * 异常处理方法 该方法处理的是 sql 的 SQLIntegrityConstraintViolationException 异常
     * @return
     */
    @ExceptionHandler(java.sql.SQLIntegrityConstraintViolationException.class)
    public Result<String> exceptHandler(SQLIntegrityConstraintViolationException ex) {
        String exMessage = ex.getMessage();

        // 判断是不是 username 重复的异常
        if (exMessage.contains("Duplicate entry")) {
            String[] split = exMessage.split(" ");
            String errorMsg = "用户名" + split[2] + "已经存在了...";
            return Result.error(errorMsg);
        }

        return Result.error("未知错误...");
    }
}
```

## 3 员工信息分页查询

### 3.1 需求分析

系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。

1. 页面发送`ajax`请求，将分页查询参数（`page`、`pageSize`、`name`）提交到服务端
2. 服务端`Controller`接收页面提交的数据并调用`Service`查询数据
3. `Service`调用`Mapper`操作数据库，查询分页数据
4. `Controller`将查询到的分页数据响应给页面
5. 页面接收到分页数据并通过`Elementul`的`Table`组件展示到页面上

### 3.2 代码实现

- 配置分页器插件

  ```java
  import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
  import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  /**
   * 配置 MP 的分页插件
   */
  @Configuration
  public class MybatisPlusConfig {
  
      @Bean
      public MybatisPlusInterceptor mybatisPlusInterceptor() {
          MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
          mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
          return mybatisPlusInterceptor;
      }
  }
  ```

- 分页查询

  ```java
  /**
       * 员工信息分页查询
       * @param page
       * @param pageSize
       * @param name
       * @return
       */
  @GetMapping("page")
  public Result<Page<Employee>> page(Integer page, Integer pageSize, String name) {
      log.info("员工分页查询：page = {}， pageSize = {}，name = {}", page, pageSize, name);
  
      // 分页构造器
      Page<Employee> pageInfo = new Page<>(page, pageSize);
      // 条件构造器
      LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
      queryWrapper.like(name != null, Employee:: getName, name);  // 满足第一个条件时 才会加入构造
  
      // 执行查询
      employeeService.page(pageInfo, queryWrapper);
      return Result.success(pageInfo);
  }
  ```

## 4 启用 / 禁用员工账号

### 4.1 需求分析

在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启用后的员工可以正常登录。

需要注意，只有管理员（`admin`用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用禁用按钮不显示。

### 4.2 代码实现

```java
/**
     * 根据 id 修改员工信息
     * @param employee
     * @return
     */
@PutMapping
public Result<String> update(HttpServletRequest request, @RequestBody Employee employee) {
    log.info("{}", employee);

    Long empId = (Long) request.getSession().getAttribute("employee");

    if (employee.getStatus() != null){
        // todo: 查管理员
        if (empId != 1L){
            return Result.error("没有权限...");
        }
    }

    employee.setUpdateUser(empId);
    employee.setUpdateTime(LocalDateTime.now());
    employeeService.updateById(employee);
    return Result.success("员工信息更新成功...");
}
```

### 4.2 Long 类型精度丢失

前面我们已经发现了问题的原因，即 js 对 Long 型数据进行处理时丢失精度，导致提交的 id 和数据库中的 id 不一致。如何解决这个问题？我们可以在服务端给页面响应 json 数据时进行处理，将 Long 型数据统一转为 String 字符串

- 提供对象转换器`JacksonObjectMapper`，基于`Jackson`进行 Java 对象到 json 数据的转换

  ```java
  import com.fasterxml.jackson.databind.DeserializationFeature;
  import com.fasterxml.jackson.databind.ObjectMapper;
  import com.fasterxml.jackson.databind.module.SimpleModule;
  import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
  import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
  import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
  import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
  import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
  import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
  import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
  import java.math.BigInteger;
  import java.time.LocalDate;
  import java.time.LocalDateTime;
  import java.time.LocalTime;
  import java.time.format.DateTimeFormatter;
  import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
  
  /**
   * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
   * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
   * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
   */
  public class JacksonObjectMapper extends ObjectMapper {
  
      public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
      public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
      public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";
  
      public JacksonObjectMapper() {
          super();
          //收到未知属性时不报异常
          this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);
  
          //反序列化时，属性不存在的兼容处理
          this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
  
          SimpleModule simpleModule = new SimpleModule()
                  .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                  .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                  .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
  
                  .addSerializer(BigInteger.class, ToStringSerializer.instance)
                  .addSerializer(Long.class, ToStringSerializer.instance)
                  .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                  .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                  .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
  
          //注册功能模块 例如，可以添加自定义序列化器和反序列化器
          this.registerModule(simpleModule);
      }
  }
  ```

- 在`WebMvcConfig`配置类中扩展 Spring mvc 的消息转换器，在此消息转换器中使用我们自己提供的对象转换器进行 Java 对象到 Json 数据的转换

  ```java
  /**
       * 扩展 mvc 框架的消息转换器
       * @param converters
       */
  @Override
  protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
      // 创建一个新的消息转换器
      MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
      // 设置这个新的对象转换器底层使用我们的转换器
      messageConverter.setObjectMapper(new JacksonObjectMapper());
      // 把上面的消息转换器 追加到mvc框架的转换器集合中
      // 索引为 0 放到首位 会优先使用我们的消息转换器
      converters.add(0, messageConverter);
  }
  ```

## 5 编辑员工信息

### 5.1 需求分析

在员工管理列表页面点击编辑按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最后点击保存按钮完成编辑操作

### 5.2 代码开发

1. 点击编辑按钮时，页面跳转到 add.html，并在 url 中携带参数[员工id]
2. 在 add.html 页面获取 url 中的参数[员工id]
3. 发送 ajax 请求，请求服务端，同时提交员工 id 参数
4. 服务端接收请求，根据员工 id 查询员工信息，将员工信息以 json 形式响应给页面
5. 页面接收服务端响应的 json 数据，通过 VUE 的数据绑定进行员工信息回显
6. 点击保存按钮，发送 ajax 请求，将页面中的员工信息以 json 方式提交给服务端
7. 服务端接收员工信息，并进行处理，完成后给页面响应
8. 页面接收到服务端响应信息后进行相应处理

# day 03 分类管理业务

## 1 公共字段自动填充

### 1.1 需求分析

前面我们已经完成了后台系统的员工管理功能开发，在新增员工时需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工时需要设置修改时间和修改人等字段。这些字段属于公共字段，也就是很多表中都有这些字段。

### 1.2 代码实现

Mybatis Plus 公共字段自动填充，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码

1. 在实体类的属性上加入`@TableField`注解，指定自动填充的策略
2. 按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现`MetaobiectHandler`接口

代码在下面捏

### 1.3 功能完善：ThreadLocal

#### 1.3.1 发现问题

前面我们已经完成了公共字段自动填充功能的代码开发，但是还有一个问题没有解决，就是我们在自动填充`createUser`和`updateUser`时设置的用户`id`是固定值，现在我们需要改造成动态获取当前登录用户的`id`。有的同学可能想到，用户登录成功后我们将用户`id`存入了`HttpSession`中，现在我从`HttpSession`中获取不就行了？注意，我们在`MyMetaObjectHandler`类中是不能获得`HttpSession`对象的，所以我们需要通过其他方式来获取登录用户`id`。

可以使用`ThreadLocal`来解决此问题，它 JDK 中提供的一个类。

在学习`ThreadLocal`之前，我们需要先确认一个事情，就是客户端发送的每次 http 请求，对应的在服务端都会分配一个新的线程来处理,在处理过程中涉及到下面类中的方法都属于相同的一个线程：

- `LoginCheckFilter`的`doFilter`方法
- `EmployeeController`的`update`方法
- `MyMetaobjectHandler`的`updateFill`方法

可以在上面的三个方法中分别加入代码来获取当前线程`id` 

```java
long id = Thread.currentThread().getId();
log.info("线程id: {}", id);
```

执行编辑员工功能进行验证，通过观察控制台输出可以发现，一次请求对应的线程 id 是相同的。

#### 1.3.2 什么是 ThreadLocal
`ThreadLocal`并不是一个`Thread`，而是`Thread`的局部变量。当使用`ThreadLocal`维护变量时，`ThreadLocal`为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。`ThreadLocal`为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。
#### 1.3.3 ThreadLocal 常用方法

- 设置当前线程的线程局部变量的值

  ```java
  public void set(T value)
  ```

- 返回当前线程所对应的线程局部变量的值

  ```java
  public T get()
  ```

我们可以在`LoginCheckFilter`的`doFilter`方法中获取当前登录用户 id，并调用`ThreadLocal`的`set`方法来设置当前线程的线程局部变量的值（用户 id），然后在`MyMetaobjectHandler`的`updateFill`方法中调用`ThreadLocal`的`get`方法来获得当前线程所对应的线程局部变量的值（用户 id）。

#### 1.3.4 具体代码

1. 编写`BaseContext`工具类，基于`ThreadLocal`封装的工具类
2. 在`LoginCheckFilter`的`doFilter`方法中调用`BaseContext`来设置当前登录用户的 id
3. 在`MyMetaobjectHandler`的方法中调用`BaseContext`获取登录用户的 id

```java
/**
 * 基于 ThreadLocal 封装的工具类 用户保存和获取当前的登录名 id
 */
public class BaseContext {
    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }
}
```

```java
...
if (attribute != null) {
    log.info("用户已登录，用户 id 为 {}", attribute);

    // 设置 ThreadLocal 的值为 用户 id 便于后面取值
    BaseContext.setCurrentId((Long) attribute);

    filterChain.doFilter(request, response);
    return;
}
...
```

```java
/**
 * 自定义元数据处理器
 */
@Component
@Slf4j
public class MyMeteObjectHandle implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("公共字段自动填充 【insert】");
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("password", DigestUtils.md5Digest("123456".getBytes()));
        metaObject.setValue("createUser", BaseContext.getCurrentId());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        log.info("公共字段自动填充 【update】");
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }
}
```

## 2 新增分类

### 2.1 需求分析

后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类。当我们在后台系统中添加菜品时需要选择一个菜品分类，当我们在后台系统中添加一个套餐时需要选择一个套餐分类，在移动端也会按照菜品分类和套餐分类来展示对应的菜品和套餐。

### 2.2 代码实现

```java
/**
 * 新增 菜品 或 套餐 分类
 * @param category
 * @return
 */
@PostMapping
public Result<String> save(@RequestBody Category category) {
    log.info("新增: {}", category);
    categoryService.save(category);
    return Result.success("新增成功");
}
```

## 3 分类信息分页查询

```java
public Result<IPage<Category>> page(Integer page, Integer pageSize) {
    log.info("分页查询 page = {}，pageSiz = {}", page, pageSize);
    // 分页构造器
    Page<Category> pageInfo = new Page<>(page, pageSize);
    // 条件构造器 需要用 sort 字段进行排序
    LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.orderByAsc(Category:: getSort);
    categoryService.page(pageInfo, queryWrapper);

    return Result.success(pageInfo);
}
```

## 4 删除分类

### 4.1 需求分析

在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除。

### 4.2 代码实现

由于分类是与菜品或套餐有对应关系，故删除分类时是不能直接删除的。此处需要在删除前查数据库，判断待删除的分类是否有对应的菜品或套餐。所以需要我们自己去写删除的逻辑。

- 在`categoryService`接口中定义我们自己的`remove()`方法

  ```java
  public interface CategoryService extends IService<Category> {
  
      public void remove(Long id);
  }
  ```

- 在`categoryServiceImpl`中实现我们自己的`remove()`方法

  ```java
  import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
  import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
  import com.itheima.reggie.common.CustomException;
  import com.itheima.reggie.entity.Category;
  import com.itheima.reggie.entity.Dish;
  import com.itheima.reggie.entity.Setmeal;
  import com.itheima.reggie.mapper.CategoryMapper;
  import com.itheima.reggie.service.CategoryService;
  import com.itheima.reggie.service.DishService;
  import com.itheima.reggie.service.SetmealService;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Service;
  
  @Service
  public class CategoryServiceImpl extends ServiceImpl<CategoryMapper, Category> implements CategoryService {
  
      @Autowired
      private DishService dishService;
  
      @Autowired
      private SetmealService setmealService;
  
      /**
       * 根据 id 有条件的删除分类
       *
       * @param id
       */
      @Override
      public void remove(Long id) {
          // 查询当前分类是否关联了菜品，如果已经关联，抛出一个业务异常
          LambdaQueryWrapper<Dish> dishLambdaQueryWrapper = new LambdaQueryWrapper<>();
          dishLambdaQueryWrapper.eq(Dish:: getCategoryId, id);
  
          int dishCount = dishService.count(dishLambdaQueryWrapper);
          if (dishCount > 0) {
              // 关联了菜品
              throw new CustomException("当前分类下关联了菜品，不能删除...");
          }
  
          // 查询当前分类是否关联了套餐，如果已经关晚抛出一个业务异常
          LambdaQueryWrapper<Setmeal> setmealLambdaQueryWrapper = new LambdaQueryWrapper<>();
          setmealLambdaQueryWrapper.eq(Setmeal:: getCategoryId, id);
  
          int setmealCount = setmealService.count(setmealLambdaQueryWrapper);
          if (setmealCount > 0) {
              // 关联了套餐
              throw new CustomException("当前分类下关联了套餐，不能删除...");
          }
  
          // 正常删除
          super.removeById(id);
      }
  }
  ```

- 于是便可以在`controller`中

  ```java
  /**
   * 删除分类
   * @param id
   * @return
   */
  @DeleteMapping
  public Result<String> delete(Long id) {
      categoryService.remove(id);
      return Result.success("删除分类成功");
  }
  ```

- 对于分类关联了菜品或套餐，即不能删除的情况，可以直接`return`回去结果。此处的逻辑是抛出业务异常的。故需要先定义异常

  ```java
  /**
   * 自定义业务异常类
   */
  public class CustomException extends RuntimeException{
      public CustomException(String message) {
          super(message);
      }
  }
  ```

  即可在全局异常处理器中统一捕获异常并`response`最终`error`给前端

  ```java
  /**
   * 处理我们自己的 CustomException
   */
  @ExceptionHandler(CustomException.class)
  public Result<String> exceptHandler(CustomException ex) {
      String exMessage = ex.getMessage();
      log.error(exMessage);
  
      return Result.error(exMessage);
  }
  ```

## 5 修改分类

在分类管理列表页面点击修改按钮，弹出修改窗口，在修改窗口回显分类信息并进行修改，最后点击确定按钮完成修改操作。

```java
/**
 * 根据 id 修改
 * @param category
 * @return
 */
@PutMapping
public Result<String> update(@RequestBody Category category) {
    log.info("修改信息：{}", category);
    categoryService.updateById(category);
    return Result.success("修改分类成功...");
}
```

# day 04 菜品管理业务

## 1 文件上传下载

### 1.1 文件上传介绍

- 文件上传，也称为`upload`，是指将本地图片、视频、音频等文件上传到服务器上，可以供其他用户浏览或下载的过程。文件上传在项目中应用非常广泛，我们经常发微博、发微信朋友圈都用到了文件上传功能。

- 文件上传时，对页面的`form`表单有如下要求

  - `method="post"`：采用post方式提交数据
  - `enctype="multipart/form-data'`：采用`multipart`格式上传文件
  - `type="file"`：使用`input`的`file`控件上传

- 举个例子

  ```html
  <form method="post" action="/common/upload" enctype="multipart/form-data">
      <input name="myFile" type="file"/>
      <input type="submit" value="提交"/>                          
  </form>
  ```

- 文件上传，页面端可以使用 ElementUl 提供的上传组件

- 服务端要接收客户端页面上传的文件，通常都会使用 Apache 的两个组件

  - `commons-fileupload`
  - `commons-io`

- Spring 框架在 spring-web 包中对文件上传进行了封装，大大简化了服务端代码，我们只需要在`Controller`的方法中声明一个`MultipartFile`类型的参数即可接收上传的文件。

### 1.2 文件下载介绍

- 文件下载，也称为 download，是指将文件从服务器传输到本地计算机的过程
- 通过浏览器进行文件下载，通常有两种表现形式
  - 以附件形式下载，弹出保存对话框，将文件保存到指定磁盘目录
  - 直接在浏览器中打开
- 通过浏览器进行文件下载，本质上就是服务端将文件以流的形式写回浏览器的过程

### 1.3 文件上传下载代码

```java
import com.itheima.reggie.common.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.UUID;

/**
 * 文件上传和下载
 */
@RestController
@Slf4j
@RequestMapping("common")
public class CommonController {

    @Value("${reggie.file.path}")
    private String basePath;

    /**
     * 文件上传
     * @param file
     * @return
     * @throws IOException
     */
    @PostMapping("/upload")
    // file 这个参数名必须要和 name 一样
    // Content-Disposition: form-data; name="file"; filename="image-20230315112348651.png"
    public Result<String> upload(MultipartFile file) throws IOException {
        // file 是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除
        log.info(file.toString());

        // 判断文件路径是否存在
        File dir = new File(basePath);
        if (!dir.exists()) {
            dir.mkdirs();
        }

        String originalFilename = file.getOriginalFilename();
        // file.transferTo(new File(basePath + originalFilename));  // 使用原始文件名

        String fileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf("."));
        file.transferTo(new File(basePath + fileName));
        return Result.success(fileName);  // 图片回显时 会直接请求文件下载的路径 参数为文件保存时的名字
    }

    /**
     * 文件下载
     * @param name
     * @param response
     */
    @GetMapping("/download")
    public void download(String name, HttpServletResponse response) throws IOException {
        // 输入流 读取文件
        FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));

        // 输出流
        ServletOutputStream responseOutputStream = response.getOutputStream();
        response.setContentType("image/jpeg");

        int len;
        byte[] bytes = new byte[1024];
        while ((len = fileInputStream.read(bytes)) != -1) {
            responseOutputStream.write(bytes, 0, len);
            responseOutputStream.flush();
        }

        responseOutputStream.close();
        fileInputStream.close();
    }
}
```

## 2 新增菜品

### 2.1 需求分析

后台系统中可以管理菜品信息，通过新增功能来添加一个新的菜品，在添加菜品时需要选择当前菜品所属的菜品分类并且需要上传菜品图片，在移动端会按照菜品分类来展示对应的菜品信息。

在开发代码之前，需要梳理一下新增菜品时前端页面和服务端的交互过程

1. 页面（backend/page/food/add.html）发送 ajax 请求，请求服务端获取菜品分类数据并展示到下拉框中
2. 页面发送请求进行图片上传，请求服务端将图片保存到服务器
3. 页面发送请求进行图片下载，将上传的图片进行回显
4. 点击保存按钮，发送 ajax 请求，将菜品相关数据以 Json 形式提交到服务端

开发新增菜品功能，其实就是在服务端编写代码去处理前端页面发送的这4次请求即可

### 2.2 代码实现

#### 2.2.1 DTO

DTO，全称为Data Transfer Object，即数据传输对象，一般用于展示层与服务层之间的数据传输。

此处前端提交的数据，有一个`flavors`字段，故目前的实体类无法接收。

```json
{
	"name": "00",
	"price": 2000,
	"code": "",
	"image": "b0b17090-eb4c-42a4-ae5e-1f6bc07d98a8.jpg",
	"description": "",
	"status": 1,
	"categoryId": "1397844263642378242",
	"flavors": [{
		"name": "甜味",
		"value": "[\"无糖\",\"少糖\",\"半糖\",\"多糖\",\"全糖\"]",
		"showOption": false
	}, {
		"name": "辣度",
		"value": "[\"不辣\",\"微辣\",\"中辣\",\"重辣\"]",
		"showOption": false
	}]
}
```

定义一个 DTO 为 DishDto。继承了`Dish`实体

```java
import com.itheima.reggie.entity.Dish;
import com.itheima.reggie.entity.DishFlavor;
import lombok.Data;
import java.util.ArrayList;
import java.util.List;

@Data
public class DishDto extends Dish {
    private List<DishFlavor> flavors = new ArrayList<>();
    private String categoryName;
    private Integer copies;
}
```

#### 2.2.2 具体代码

- 由于需要自定义 所以在`DishService`中定义`saveWithFlavor`方法，在`DishServiceImpl`中实现`saveWithFlavor`方法

  ```java
  public interface DishService extends IService<Dish> {
  
      // 新增菜品 同时插入菜品表 与 口味表
      public void saveWithFlavor(DishDto dishDto);
  }
  ```

  ```java
  /**
   * 新增菜品 同时插入菜品表 与 口味表
   *
   * @param dishDto
   */
  @Override
  @Transactional
  public void saveWithFlavor(DishDto dishDto) {
      // 保存基本信息到菜品表
      // this.save(dishDto);
      save(dishDto);
  
      // 保存口味表
      // 注意 现在的 Flavor 中 只有 name 和 value。没有 dishId 即不能将 口味 和 和菜品形成关系
      // 由于上面已经将 dish 写入了数据库 故 dishId 已经回写了 故可以直接拿值
      Long dishId = dishDto.getId();
      List<DishFlavor> flavors = dishDto.getFlavors();
      for (DishFlavor flavor : flavors) {
          flavor.setDishId(dishId);
      }
  
      dishFlavorService.saveBatch(flavors);
  }
  ```

- 由于是同时操控多张 SQL 表，故需要加上`@Transactional`注解。同时在启动类中开始事务支持

  ```java
  @Slf4j
  @SpringBootApplication
  @ServletComponentScan  // 过滤器支持
  @EnableTransactionManagement  // 开启事务支持
  public class ReggieApplication {
      public static void main(String[] args) {
          SpringApplication.run(ReggieApplication.class, args);
          log.info("项目启动成功...");
      }
  }
  ```

## 3 菜品信息分页查询

### 3.1 需求分析

系统中的菜品数据很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。

1. 页面（backend/page/food/list.html）发送 ajax 请求，将分页查询参数`page`、`pageSize`、`name`）提交到服务端，获取分页数据
2. 页面发送请求，请求服务端进行图片下载，用于页面图片展示

开发菜品信息分页查询功能，其实就是在服务端编写代码去处理前端页面发送的这 2 次请求即可

### 3.2 代码实现

```java
/**
 * 菜品分页查询
 * 页面需要返回的数据中有 categoryName 字段
 * 故此处返回的是 有 categoryName 字段的 DishDto 的实体
 * 使用 对象拷贝 把查到的数据拷贝给 DishDto 并单独给 categoryName 字段赋值
 * @param page
 * @param pageSize
 * @param name
 * @return
 */
@GetMapping("/page")
public Result<Page<DishDto>> page(Integer page, Integer pageSize, String name) {
    log.info("菜品分页查询：page = {}, pageSize = {}, name = {}", page, pageSize, name);
    // 返回的数据
    Page<DishDto> dishDtoPage = new Page<>();

    //分页器
    Page<Dish> pageInfo = new Page<>(page, pageSize);

    // 条件构造器
    LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.like(name != null, Dish:: getName, name);
    queryWrapper.orderByDesc(Dish::getUpdateTime);
    // 查询数据
    dishService.page(pageInfo, queryWrapper);

    // 对象拷贝
    // 把除了 records 外的属性拷贝过去
    BeanUtils.copyProperties(pageInfo, dishDtoPage, "records");
    // 单独处理 records
    List<Dish> records = pageInfo.getRecords();
    List<DishDto> newRecords = records.stream().map(item -> {
        // new 一个 DishDto 里面有 categoryName 这一个属性
        DishDto dishDto = new DishDto();
        Long categoryId = item.getCategoryId();  // 拿到分类的 id
        String categoryName = categoryService.getById(categoryId).getName();

        BeanUtils.copyProperties(item, dishDto);
        dishDto.setCategoryName(categoryName);

        return dishDto;
    }).collect(Collectors.toList());

    // 把处理好的 newRecords 给将要返回的 dishDtoPage 里面
    dishDtoPage.setRecords(newRecords);

    return Result.success(dishDtoPage);
}
```

## 4 修改菜品

### 4.1 需求分析

在菜品管理列表页面点击修改按钮，跳转到修改菜品页面，在修改页面回显菜品相关信息并进行修改，最后点击确定按钮完成修改操作。

1. 页面发送 ajax 请求，请求服务端获取分类数据，用于菜品分类下拉框中数据展示
2. 页面发送 ajax 请求，请求服务端，根据 id 查询当前菜品信息，用于菜品信息回显页面
3. 发送请求，请求服务端进行图片下载，用于页图片回显
4. 点击保存按钮，页面发送 ajax 请求，将修改后的菜品相关数据以 json 形式提交到服务端

### 4.2 代码实现

自定义在`DishServiceImpl`中

```java
/**
 * 更新 菜品 + 口味 信息
 *
 * @param dishDto
 */
@Override
public void updateWithFlavor(DishDto dishDto) {
    // 更新 dish 表基本信息
    this.updateById(dishDto);

    // 清理 口味表 中菜品对应的口味数据
    LambdaQueryWrapper<DishFlavor> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(DishFlavor:: getDishId, dishDto.getId());
    dishFlavorService.remove(queryWrapper);

    // 新增当前的口味数据到 口味表
    List<DishFlavor> flavors = dishDto.getFlavors();
    // 口味表要添加菜品的 id 形成对应
    for (DishFlavor flavor : flavors) {
        flavor.setDishId(dishDto.getId());
    }
    dishFlavorService.saveBatch(flavors);
}
```

# day 05 套餐管理业务开发

## 5.1 新增套餐

### 5.1.1 需求分析

套餐就是菜品的集合。后台系统中可以管理套餐信息，通过新增套餐功能来添加一个新的套餐，在添加套餐时需要选择当前套餐所属的套餐分类和包含的菜品，并且需要上传套餐对应的图片，在移动端会按照套餐分类来展示对应的套餐。

1. 页面（backend/page/ombo/add.htm）发送 ajax 请求，请求服务端获取套餐分类数据并展示到下拉框中
2. 页面发送 ajax 请求，请求服务端获取菜品分类数据并展示到添加菜品窗口中
3. 页面发送 ajax 请求，请求服务端，根据菜品分类查询对应的菜品数据并展示到添加菜品窗口中
4. 页面发送请求进行图片上传，请求服务端将图片保存到服务器
5. 页面发送请求进行图片下载，将上传的图片进行回显
6. 点击保存按钮，发送 ajax 请求，将套餐相关数据以 json 形式提交到服务端

### 5.1.2 代码实现

#### 5.1.2.1 查询菜品分类

```java
/**
 * 根据条件查菜品数据
 * @param dish
 * @return
 */
@GetMapping("/list")
public Result<List<Dish>> list(Dish dish) {
    log.info("根据条件查询 dish: {}", dish);
    LambdaQueryWrapper<Dish> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(dish.getCategoryId() != null, Dish::getCategoryId, dish.getCategoryId());
    queryWrapper.eq(Dish::getStatus, 1);
    queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime);

    List<Dish> list = dishService.list(queryWrapper);
    return Result.success(list);
}
```



## 5.2 套餐信息分页查询

```java
/**
 * 套餐分页查询
 *
 * @param page
 * @param pageSize
 * @param name
 * @return
 */
@GetMapping("/page")
public Result<Page<SetmealDto>> page(Integer page, Integer pageSize, String name) {
    log.info("套餐分页查询：page = {}，pageSize = {}，name = {}", page, pageSize, name);

    Page<Setmeal> pageInfo = new Page<>(page, pageSize);
    Page<SetmealDto> pageDto = new Page<>();

    LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.like(name != null, Setmeal::getName, name);
    queryWrapper.orderByDesc(Setmeal::getUpdateTime);
    setmealService.page(pageInfo, queryWrapper);

    // 对象拷贝
    BeanUtils.copyProperties(pageInfo, pageDto, "records");

    List<SetmealDto> setmealDtoList = pageInfo.getRecords().stream().map(record -> {
        // 每一个 record 是一个 Setmeal
        SetmealDto setmealDto = new SetmealDto();
        BeanUtils.copyProperties(record, setmealDto);
        setmealDto.setCategoryName(categoryService.getById(record.getCategoryId()).getName());
        return setmealDto;
    }).collect(Collectors.toList());

    pageDto.setRecords(setmealDtoList);

    return Result.success(pageDto);
}
```

## 5.3 删除套餐

所以是不是可以理解为，这个操作走完，就可以默认删除成功。如果逻辑上不符和删除条件，则直接抛业务异常，由全局异常处理器返回报错信息。

这样的话，是不是不用把`Reuslt`传来传去，使各版块更加独立。

```java
/**
 * 删除套餐
 * 前提是已经停售
 *
 * @param ids
 * @return
 */
@DeleteMapping
public Result<String> deleteByIds(@RequestParam List<Long> ids) {
    log.info("批量删除：{}", ids);

    // 默认这个操作走完 都是删除成功的
    // 删除失败的会直接抛业务异常
    setmealService.removeWithDish(ids);
    return Result.success("删除成功");
}
```

```java
/**
 * 删除 套餐 与 关联 的菜品
 * 前提是已经停售
 *
 * @param ids
 * @return
 */
@Transactional
@Override
public void removeWithDish(List<Long> ids) {
    // 判断是否停售
    // select count(*) from setmeal where id in ids and status == 1
    LambdaQueryWrapper<Setmeal> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(Setmeal:: getStatus, 1);
    queryWrapper.in(Setmeal:: getId, ids);
    int count = this.count(queryWrapper);
    if (count > 0) {
        throw new CustomException("不能删除未停售的套餐！");
    }

    // 都停售了 处理删除业务
    // 删除套餐
    this.removeByIds(ids);

    // 删除关联数据
    LambdaQueryWrapper<SetmealDish> queryWrapper1 = new LambdaQueryWrapper<>();
    queryWrapper1.in(SetmealDish:: getSetmealId, ids);
    setmealDishService.remove(queryWrapper1);
}
```

# day 05 手机验证码登录

## 1 短信发送

### 1.1 短信服务介绍

- 目前市面上有很多第三方提供的短信服务，这些第三方短信服务会和各个运营商（移动、联通、电信）对接，我们只需要注册成为会员并且按照提供的开发文档进行调用就可以发送短信。需要说明的是，这些短信服务一般都是收费服务。

- 常用短信服务

  - 阿里云

  - 华为云

  - 腾讯云

  - 京东

  - 梦网

  - 乐信

### 1.2 阿里云短信服务

- 阿里云短信服务（Short Message Service）是广大企业客户快速触达手机用户所优选使用的通信能力。调用 API 或用群发助手，即可发送验证码、通知类和营销类短信;国内验证短信秒级触达，到达率最高可达99%，国际/港澳台短信覆盖200多个国家和地区，安全稳定，广受出海企业选用。

- 应用场景

  - 验证码

  - 短信通知

  - 推广短信



### 1.3 代码开发







1. 

| 0    | 0    | 0    |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |











![image-20230507191642921](assets/image-20230507191642921.png)























