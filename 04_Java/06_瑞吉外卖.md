2023年4月25日14:23 虔诚地打开

<img src="assets/image-20230425142323516.png" alt="image-20230425142323516" style="zoom:25%;" />

# 瑞吉外卖

## 前置知识

- Java基础知识
- Java Web
- MySQL
- Spring BootSSM（Spring、Spring MVC、MyBatis）
- Maven

## 学习收获

- 了解企业项目开发的完整流程，增长开发经验
- 了解需求分析的过程，提高分析和设计能力
- 对所学技术进行灵活应用，提高编码能力
- 解决各种异常情况，提高代码调试能力

# day 01

## 1 软件开发整体介绍

### 1.1 软件开发流程

- 需求分析

  产品原型、需求规格说明书

- 设计

  产品文档、UI 界面设计、概要设计、详细设计、数据库设计

- 编码

  项目代码、单元测试

- 测试

  测试用例、测试报告

- 上线运维

  软件环境安装、配置

### 1.2 角色分工

- 项目经理：对整个项目负责，任务分配、把控进度
- 产品经理：进行需求调研，输出需求调研文档、产品原型等
- UI 设计师：根据产品原型输出界面效果图
- 架构师：项目整体架构设计、技术选型等
- 开发工程师：代码实现
- 测试工程师：编写测试用例，输出测试报告运维工程师:软件环境搭建、项目上线

### 1.3 软件环境

- 开发环境（development）：开发人员在开发阶段使用的环境，一般外部用户无法访问
- 测试环境（testing）：专门给测试人员使用的环境，用于测试项目，一般外部用户无法访问
- 生产环境（production）：即线上环境，正式提供对外服务的环境

## 2 瑞吉外卖项目介绍

### 2.1 项目介绍

本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括系统管理后台和移动端应用两部分其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的菜品、套餐、订单等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等。

本项目共分为 3 期进行开发

- 第一期主要实现基本需求，其中移动端应用通过 H5 实现，用户可以通过手机浏览器访问
- 第二期主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便
- 第三期主要针对系统进行优化升级，提高系统的访问性能。

### 2.2 产品原型展示

产品原型，就是一款产品成型之前的一个简单的框架，就是将页面的排版布局展现出来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的功能。

产品原型主要用于展示项目的功能，并不是最终的页面效果。

### 2.3 技术选型

![image-20230425145949134](assets/image-20230425145949134.png)

### 2.4 功能架构

- 移动端前台（H5、微信小程序）
  - 手机号登录
  - 菜品规格
  - 微信登录
  - 购物车
  - 地址管理
  - 下单
  - 历史订单
  - 菜品浏览
- 系统管理后台
  - 分类管理
  - 员工登录
  - 菜品管理
  - 员工退出
  - 套餐管理
  - 员工管理
  - 菜品口味管理
  - 订单管理

### 2.5 角色

- 后台系统管理员：登录后台管理系统，拥有后台系统中的所有操作权限
- 后台系统普通员工：登录后台管理系统，对菜品、套餐、订单等进行管理
- C端用户：登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等

## 3 开发环境搭建

### 3.1 数据库

```sql
CREATE DATABASE reggie CHARACTER SET utf8mb4;
```

|       表名        | 说明             |
| :---------------: | ---------------- |
|    `employee`     | 员工表           |
|    `category`     | 菜品和套餐分类表 |
|      `dish`       | 菜品表           |
|     `setmeal`     | 套餐表           |
|  `setmeal_dish`   | 套餐菜品关系表   |
| `dishdish_flavor` | 菜品口味关系表   |
|      `user`       | 用户表（C端）    |
|  `address_book`   | 地址簿表         |
|  `shopping_cart`  | 购物车表         |
|     `orders`      | 订单表           |
|  `order_detail`   | 订单明细表       |

### 3.2 Maven

### 3.3 启动类与相关配置

将静态资源`backend`与`front`放置到`resources`文件夹。由于 SpringBoot 默认的静态文件是在`static`或`template`文件夹，所以创建配置类进行配置。

```java
@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 设置静态资源映射
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        log.info("开始静态资源映射...");
        // classpath: 指的是 resources 文件夹
        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");  // 斜线不要漏了...
        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");
    }
}
```

## 4 后台登录功能开发

### 4.2 代码开发

1. 将页面提交的密码`password`进行 md5 加密处理
2. 根据页面提交的用户名`username`查询数据库
3. 如果没有查询到则返回登录失败结果
4. 密码比对，如果不一致则返回登录失败结果
5. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果
6. 登录成功，将员工`id`存入`Session`并返回登录成功结果

![image-20230427105348146](assets/image-20230427105348146.png)

### 4.3 功能测试

测啊测，测测测...

## 5 后台退出功能开发

- 用户点击页面中退出按钮，发送请求，请求地址为`/employee/logout`，请求方式为POST
- 我们只需要在`Controller`中创建对应的处理方法即可，具体的处理逻辑
  - 清理`Session`中的用户`id`
  - 返回结果

# day 02 员工管理业务

## 1 完善登录功能

### 1.1 需求分析

前面我们已经完成了后台系统的员工登录功能开发，但是还存在一个问题：用户如果不登录，直接访问系统首页面，照样可以正常访问。这种设计并不合理，我们希望看到的效果应该是，只有登录成功后才可以访问系统中的页面，如果没有登录则跳转到登录页面。

那么，具体应该怎么实现呢？答案就是使用过滤器或者拦截器，在过滤器或者拦截器中判断用户是否已经完成登录，如果没有登录则跳转到登录页面，

### 1.2 代码实现

1. 创建自定义过滤器`LoginCheckFilter`
2. 在启动类上加入注解`@ServletComponentScan`
3. 完善过滤器的处理逻辑

过滤器具体的处理逻辑如下：

1. 获取本次请求的 URL
2. 判断本次请求是否需要处理
3. 如果不需要处理，则直接放行
4. 判断登录状态，如果已登录，则直接放行
5. 如果未登录则返回未登录结果

![image-20230503115602088](assets/image-20230503115602088.png)

```java
package com.itheima.reggie.filter;

import com.alibaba.fastjson.JSON;
import com.itheima.reggie.common.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 检查用户是否完成登录
 */
@Slf4j
@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    // 路径匹配器 支持通配符
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        // 1. 获取本次请求的 URL
        String requestURI = request.getRequestURI();
        log.info("拦截到请求：{}", requestURI);

        // 2. 判断本次请求是否需要处理
        // 定义不需要处理的请求路径
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "/front/**",
        };
        boolean check = check(urls, requestURI);

        // 3. 如果不需要处理，则直接放行
        if (check) {
            log.info("本次请求不需要处理：{}", requestURI);
            filterChain.doFilter(request, response);
            return;
        }

        // 4. 判断登录状态，如果已登录，则直接放行
        Object attribute = request.getSession().getAttribute("employee");
        // log.info("\n\n\n{}\n\n\n{}\n\n\n", attribute, attribute.toString());
        if (attribute != null) {
            log.info("用户已登录，用户 id 为 {}", attribute);

            filterChain.doFilter(request, response);
            return;
        }

        // 5. 如果未登录则返回未登录结果
        response.getWriter().write(JSON.toJSONString(Result.error("NOTLOGIN")));
        log.info("用户未登录");
        return;
    }

    /**
     * 路径匹配 判断本次请求是否需要放行
     * @param urls
     * @param requestURI
     * @return true: 放行 false: 需要校验是否登录
     */
    public boolean check(String[] urls, String requestURI) {
        for (String url : urls) {
            boolean match = PATH_MATCHER.match(url, requestURI);
            if (match) {
                return true;
            }
        }
        return false;
    }
}
```

## 2 新增员工

### 2.1 需求分析

1. 页面发送`ajax`请求，将新增员工页面中输入的数据以`json`的形式提交到服务端
2. 服务端`Controller`接收页面提交的数据并调用`Service`将数据进行保存
3. `Service`调用`Mapper`操作数据库，保存数据

前面的程序还存在一个问题，就是当我们在新增员工时输入的账号已经存在，由于`emplovee`表中对该字段加入了唯一约束，此时程序会抛出异常：

```java
java.sql.SQLIntegrityConstraintViolationException: Duplicate entry 'fafa' for key 'employee.idx_username'
```

### 2.2 代码实现

```java
/**
 * 新增员工
 * @param employee
 * @return
 */
@PostMapping
public Result<String> save(@RequestBody Employee employee, HttpServletRequest request) {
    log.info("新增员工，员工信息：{}", employee);

    // 初始密码
    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));
    employee.setCreateTime(LocalDateTime.now());
    employee.setUpdateTime(LocalDateTime.now());
    employee.setCreateUser((Long) request.getSession().getAttribute("employee"));
    employee.setUpdateUser((Long) request.getSession().getAttribute("employee"));

    employeeService.save(employee);

    return Result.success("添加成功");
}
```

### 2.3 全局异常处理器

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常处理器
 */
@ControllerAdvice(annotations = {RestController.class, Controller.class})  // 捕获加了这些注解的类所抛出的异常
@ResponseBody
@Slf4j
public class GlobalExceptionHandle {

    /**
     * 异常处理方法 该方法处理的是 sql 的 SQLIntegrityConstraintViolationException 异常
     * @return
     */
    @ExceptionHandler(java.sql.SQLIntegrityConstraintViolationException.class)
    public Result<String> exceptHandler(SQLIntegrityConstraintViolationException ex) {
        String exMessage = ex.getMessage();

        // 判断是不是 username 重复的异常
        if (exMessage.contains("Duplicate entry")) {
            String[] split = exMessage.split(" ");
            String errorMsg = "用户名" + split[2] + "已经存在了...";
            return Result.error(errorMsg);
        }

        return Result.error("未知错误...");
    }
}
```

## 3 员工信息分页查询

### 3.1 需求分析

系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。

1. 页面发送`ajax`请求，将分页查询参数（`page`、`pageSize`、`name`）提交到服务端
2. 服务端`Controller`接收页面提交的数据并调用`Service`查询数据
3. `Service`调用`Mapper`操作数据库，查询分页数据
4. `Controller`将查询到的分页数据响应给页面
5. 页面接收到分页数据并通过`Elementul`的`Table`组件展示到页面上

### 3.2 代码实现

- 配置分页器插件

  ```java
  import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
  import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
  import org.springframework.context.annotation.Bean;
  import org.springframework.context.annotation.Configuration;
  
  /**
   * 配置 MP 的分页插件
   */
  @Configuration
  public class MybatisPlusConfig {
  
      @Bean
      public MybatisPlusInterceptor mybatisPlusInterceptor() {
          MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
          mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
          return mybatisPlusInterceptor;
      }
  }
  ```

- 分页查询

  ```java
  /**
       * 员工信息分页查询
       * @param page
       * @param pageSize
       * @param name
       * @return
       */
  @GetMapping("page")
  public Result<Page<Employee>> page(Integer page, Integer pageSize, String name) {
      log.info("员工分页查询：page = {}， pageSize = {}，name = {}", page, pageSize, name);
  
      // 分页构造器
      Page<Employee> pageInfo = new Page<>(page, pageSize);
      // 条件构造器
      LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
      queryWrapper.like(name != null, Employee:: getName, name);  // 满足第一个条件时 才会加入构造
  
      // 执行查询
      employeeService.page(pageInfo, queryWrapper);
      return Result.success(pageInfo);
  }
  ```

## 4 启用 / 禁用员工账号

### 4.1 需求分析

在员工管理列表页面，可以对某个员工账号进行启用或者禁用操作。账号禁用的员工不能登录系统，启用后的员工可以正常登录。

需要注意，只有管理员（`admin`用户）可以对其他普通用户进行启用、禁用操作，所以普通用户登录系统后启用禁用按钮不显示。

### 4.2 代码实现

```java
/**
     * 根据 id 修改员工信息
     * @param employee
     * @return
     */
@PutMapping
public Result<String> update(HttpServletRequest request, @RequestBody Employee employee) {
    log.info("{}", employee);

    Long empId = (Long) request.getSession().getAttribute("employee");

    if (employee.getStatus() != null){
        // todo: 查管理员
        if (empId != 1L){
            return Result.error("没有权限...");
        }
    }

    employee.setUpdateUser(empId);
    employee.setUpdateTime(LocalDateTime.now());
    employeeService.updateById(employee);
    return Result.success("员工信息更新成功...");
}
```

### 4.2 Long 类型精度丢失

前面我们已经发现了问题的原因，即 js 对 Long 型数据进行处理时丢失精度，导致提交的 id 和数据库中的 id 不一致。如何解决这个问题？我们可以在服务端给页面响应 json 数据时进行处理，将 Long 型数据统一转为 String 字符串

- 提供对象转换器`JacksonObjectMapper`，基于`Jackson`进行 Java 对象到 json 数据的转换

  ```java
  import com.fasterxml.jackson.databind.DeserializationFeature;
  import com.fasterxml.jackson.databind.ObjectMapper;
  import com.fasterxml.jackson.databind.module.SimpleModule;
  import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;
  import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateDeserializer;
  import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer;
  import com.fasterxml.jackson.datatype.jsr310.deser.LocalTimeDeserializer;
  import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateSerializer;
  import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer;
  import com.fasterxml.jackson.datatype.jsr310.ser.LocalTimeSerializer;
  import java.math.BigInteger;
  import java.time.LocalDate;
  import java.time.LocalDateTime;
  import java.time.LocalTime;
  import java.time.format.DateTimeFormatter;
  import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
  
  /**
   * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象
   * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象]
   * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON]
   */
  public class JacksonObjectMapper extends ObjectMapper {
  
      public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
      public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
      public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";
  
      public JacksonObjectMapper() {
          super();
          //收到未知属性时不报异常
          this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);
  
          //反序列化时，属性不存在的兼容处理
          this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
  
          SimpleModule simpleModule = new SimpleModule()
                  .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                  .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                  .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
  
                  .addSerializer(BigInteger.class, ToStringSerializer.instance)
                  .addSerializer(Long.class, ToStringSerializer.instance)
                  .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                  .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                  .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));
  
          //注册功能模块 例如，可以添加自定义序列化器和反序列化器
          this.registerModule(simpleModule);
      }
  }
  ```

- 在`WebMvcConfig`配置类中扩展 Spring mvc 的消息转换器，在此消息转换器中使用我们自己提供的对象转换器进行 Java 对象到 Json 数据的转换

  ```java
  /**
       * 扩展 mvc 框架的消息转换器
       * @param converters
       */
  @Override
  protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
      // 创建一个新的消息转换器
      MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter();
      // 设置这个新的对象转换器底层使用我们的转换器
      messageConverter.setObjectMapper(new JacksonObjectMapper());
      // 把上面的消息转换器 追加到mvc框架的转换器集合中
      // 索引为 0 放到首位 会优先使用我们的消息转换器
      converters.add(0, messageConverter);
  }
  ```

## 5 编辑员工信息

### 5.1 需求分析

在员工管理列表页面点击编辑按钮，跳转到编辑页面，在编辑页面回显员工信息并进行修改，最后点击保存按钮完成编辑操作

### 5.2 代码开发

1. 点击编辑按钮时，页面跳转到 add.html，并在 url 中携带参数[员工id]
2. 在 add.html 页面获取 url 中的参数[员工id]
3. 发送 ajax 请求，请求服务端，同时提交员工 id 参数
4. 服务端接收请求，根据员工 id 查询员工信息，将员工信息以 json 形式响应给页面
5. 页面接收服务端响应的 json 数据，通过 VUE 的数据绑定进行员工信息回显
6. 点击保存按钮，发送 ajax 请求，将页面中的员工信息以 json 方式提交给服务端
7. 服务端接收员工信息，并进行处理，完成后给页面响应
8. 页面接收到服务端响应信息后进行相应处理

# day 03 分类管理业务

## 1 公共字段自动填充

### 1.1 需求分析

前面我们已经完成了后台系统的员工管理功能开发，在新增员工时需要设置创建时间、创建人、修改时间、修改人等字段，在编辑员工时需要设置修改时间和修改人等字段。这些字段属于公共字段，也就是很多表中都有这些字段。

### 1.2 代码实现

Mybatis Plus 公共字段自动填充，也就是在插入或者更新的时候为指定字段赋予指定的值，使用它的好处就是可以统一对这些字段进行处理，避免了重复代码

1. 在实体类的属性上加入`@TableField`注解，指定自动填充的策略
2. 按照框架要求编写元数据对象处理器，在此类中统一为公共字段赋值，此类需要实现`MetaobiectHandler`接口

代码在下面捏

### 1.3 功能完善：ThreadLocal

#### 1.3.1 发现问题

前面我们已经完成了公共字段自动填充功能的代码开发，但是还有一个问题没有解决，就是我们在自动填充`createUser`和`updateUser`时设置的用户`id`是固定值，现在我们需要改造成动态获取当前登录用户的`id`。有的同学可能想到，用户登录成功后我们将用户`id`存入了`HttpSession`中，现在我从`HttpSession`中获取不就行了？注意，我们在`MyMetaObjectHandler`类中是不能获得`HttpSession`对象的，所以我们需要通过其他方式来获取登录用户`id`。

可以使用`ThreadLocal`来解决此问题，它 JDK 中提供的一个类。

在学习`ThreadLocal`之前，我们需要先确认一个事情，就是客户端发送的每次 http 请求，对应的在服务端都会分配一个新的线程来处理,在处理过程中涉及到下面类中的方法都属于相同的一个线程：

- `LoginCheckFilter`的`doFilter`方法
- `EmployeeController`的`update`方法
- `MyMetaobjectHandler`的`updateFill`方法

可以在上面的三个方法中分别加入代码来获取当前线程`id` 

```java
long id = Thread.currentThread().getId();
log.info("线程id: {}", id);
```

执行编辑员工功能进行验证，通过观察控制台输出可以发现，一次请求对应的线程 id 是相同的。

#### 1.3.2 什么是 ThreadLocal
`ThreadLocal`并不是一个`Thread`，而是`Thread`的局部变量。当使用`ThreadLocal`维护变量时，`ThreadLocal`为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。`ThreadLocal`为每个线程提供单独一份存储空间，具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问。
#### 1.3.3 ThreadLocal 常用方法

- 设置当前线程的线程局部变量的值

  ```java
  public void set(T value)
  ```

- 返回当前线程所对应的线程局部变量的值

  ```java
  public T get()
  ```

我们可以在`LoginCheckFilter`的`doFilter`方法中获取当前登录用户 id，并调用`ThreadLocal`的`set`方法来设置当前线程的线程局部变量的值（用户 id），然后在`MyMetaobjectHandler`的`updateFill`方法中调用`ThreadLocal`的`get`方法来获得当前线程所对应的线程局部变量的值（用户 id）。

#### 1.3.4 具体代码

1. 编写`BaseContext`工具类，基于`ThreadLocal`封装的工具类
2. 在`LoginCheckFilter`的`doFilter`方法中调用`BaseContext`来设置当前登录用户的 id
3. 在`MyMetaobjectHandler`的方法中调用`BaseContext`获取登录用户的 id

```java
/**
 * 基于 ThreadLocal 封装的工具类 用户保存和获取当前的登录名 id
 */
public class BaseContext {
    private static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }
}
```

```java
...
if (attribute != null) {
    log.info("用户已登录，用户 id 为 {}", attribute);

    // 设置 ThreadLocal 的值为 用户 id 便于后面取值
    BaseContext.setCurrentId((Long) attribute);

    filterChain.doFilter(request, response);
    return;
}
...
```

```java
/**
 * 自定义元数据处理器
 */
@Component
@Slf4j
public class MyMeteObjectHandle implements MetaObjectHandler {
    @Override
    public void insertFill(MetaObject metaObject) {
        log.info("公共字段自动填充 【insert】");
        metaObject.setValue("createTime", LocalDateTime.now());
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("password", DigestUtils.md5Digest("123456".getBytes()));
        metaObject.setValue("createUser", BaseContext.getCurrentId());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }

    @Override
    public void updateFill(MetaObject metaObject) {
        log.info("公共字段自动填充 【update】");
        metaObject.setValue("updateTime", LocalDateTime.now());
        metaObject.setValue("updateUser", BaseContext.getCurrentId());
    }
}
```

## 2 新增分类

### 2.1 需求分析

后台系统中可以管理分类信息，分类包括两种类型，分别是菜品分类和套餐分类。当我们在后台系统中添加菜品时需要选择一个菜品分类，当我们在后台系统中添加一个套餐时需要选择一个套餐分类，在移动端也会按照菜品分类和套餐分类来展示对应的菜品和套餐。

### 2.2 代码实现

```java
/**
 * 新增 菜品 或 套餐 分类
 * @param category
 * @return
 */
@PostMapping
public Result<String> save(@RequestBody Category category) {
    log.info("新增: {}", category);
    categoryService.save(category);
    return Result.success("新增成功");
}
```

## 3 分类信息分页查询

```java
public Result<IPage<Category>> page(Integer page, Integer pageSize) {
    log.info("分页查询 page = {}，pageSiz = {}", page, pageSize);
    // 分页构造器
    Page<Category> pageInfo = new Page<>(page, pageSize);
    // 条件构造器 需要用 sort 字段进行排序
    LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.orderByAsc(Category:: getSort);
    categoryService.page(pageInfo, queryWrapper);

    return Result.success(pageInfo);
}
```

## 4 删除分类

### 4.1 需求分析

在分类管理列表页面，可以对某个分类进行删除操作。需要注意的是当分类关联了菜品或者套餐时，此分类不允许删除。

### 4.2 代码实现





## 5 修改分类





























