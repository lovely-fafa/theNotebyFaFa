2023年4月25日14:23 虔诚地打开

<img src="assets/image-20230425142323516.png" alt="image-20230425142323516" style="zoom:25%;" />

# 瑞吉外卖

## 前置知识

- Java基础知识
- Java Web
- MySQL
- Spring BootSSM（Spring、Spring MVC、MyBatis）
- Maven

## 学习收获

- 了解企业项目开发的完整流程，增长开发经验
- 了解需求分析的过程，提高分析和设计能力
- 对所学技术进行灵活应用，提高编码能力
- 解决各种异常情况，提高代码调试能力

# day 01

## 1 软件开发整体介绍

### 1.1 软件开发流程

- 需求分析

  产品原型、需求规格说明书

- 设计

  产品文档、UI 界面设计、概要设计、详细设计、数据库设计

- 编码

  项目代码、单元测试

- 测试

  测试用例、测试报告

- 上线运维

  软件环境安装、配置

### 1.2 角色分工

- 项目经理：对整个项目负责，任务分配、把控进度
- 产品经理：进行需求调研，输出需求调研文档、产品原型等
- UI 设计师：根据产品原型输出界面效果图
- 架构师：项目整体架构设计、技术选型等
- 开发工程师：代码实现
- 测试工程师：编写测试用例，输出测试报告运维工程师:软件环境搭建、项目上线

### 1.3 软件环境

- 开发环境（development）：开发人员在开发阶段使用的环境，一般外部用户无法访问
- 测试环境（testing）：专门给测试人员使用的环境，用于测试项目，一般外部用户无法访问
- 生产环境（production）：即线上环境，正式提供对外服务的环境

## 2 瑞吉外卖项目介绍

### 2.1 项目介绍

本项目（瑞吉外卖）是专门为餐饮企业（餐厅、饭店）定制的一款软件产品，包括系统管理后台和移动端应用两部分其中系统管理后台主要提供给餐饮企业内部员工使用，可以对餐厅的菜品、套餐、订单等进行管理维护。移动端应用主要提供给消费者使用，可以在线浏览菜品、添加购物车、下单等。

本项目共分为 3 期进行开发

- 第一期主要实现基本需求，其中移动端应用通过 H5 实现，用户可以通过手机浏览器访问
- 第二期主要针对移动端应用进行改进，使用微信小程序实现，用户使用起来更加方便
- 第三期主要针对系统进行优化升级，提高系统的访问性能。

### 2.2 产品原型展示

产品原型，就是一款产品成型之前的一个简单的框架，就是将页面的排版布局展现出来，使产品的初步构思有一个可视化的展示。通过原型展示，可以更加直观的了解项目的需求和提供的功能。

产品原型主要用于展示项目的功能，并不是最终的页面效果。

### 2.3 技术选型

![image-20230425145949134](assets/image-20230425145949134.png)

### 2.4 功能架构

- 移动端前台（H5、微信小程序）
  - 手机号登录
  - 菜品规格
  - 微信登录
  - 购物车
  - 地址管理
  - 下单
  - 历史订单
  - 菜品浏览
- 系统管理后台
  - 分类管理
  - 员工登录
  - 菜品管理
  - 员工退出
  - 套餐管理
  - 员工管理
  - 菜品口味管理
  - 订单管理

### 2.5 角色

- 后台系统管理员：登录后台管理系统，拥有后台系统中的所有操作权限
- 后台系统普通员工：登录后台管理系统，对菜品、套餐、订单等进行管理
- C端用户：登录移动端应用，可以浏览菜品、添加购物车、设置地址、在线下单等

## 3 开发环境搭建

### 3.1 数据库

```sql
CREATE DATABASE reggie CHARACTER SET utf8mb4;
```

|       表名        | 说明             |
| :---------------: | ---------------- |
|    `employee`     | 员工表           |
|    `category`     | 菜品和套餐分类表 |
|      `dish`       | 菜品表           |
|     `setmeal`     | 套餐表           |
|  `setmeal_dish`   | 套餐菜品关系表   |
| `dishdish_flavor` | 菜品口味关系表   |
|      `user`       | 用户表（C端）    |
|  `address_book`   | 地址簿表         |
|  `shopping_cart`  | 购物车表         |
|     `orders`      | 订单表           |
|  `order_detail`   | 订单明细表       |

### 3.2 Maven

### 3.3 启动类与相关配置

将静态资源`backend`与`front`放置到`resources`文件夹。由于 SpringBoot 默认的静态文件是在`static`或`template`文件夹，所以创建配置类进行配置。

```java
@Slf4j
@Configuration
public class WebMvcConfig extends WebMvcConfigurationSupport {
    /**
     * 设置静态资源映射
     * @param registry
     */
    @Override
    protected void addResourceHandlers(ResourceHandlerRegistry registry) {
        log.info("开始静态资源映射...");
        // classpath: 指的是 resources 文件夹
        registry.addResourceHandler("/backend/**").addResourceLocations("classpath:/backend/");  // 斜线不要漏了...
        registry.addResourceHandler("/front/**").addResourceLocations("classpath:/front/");
    }
}
```

## 4 后台登录功能开发

### 4.2 代码开发

1. 将页面提交的密码`password`进行 md5 加密处理
2. 根据页面提交的用户名`username`查询数据库
3. 如果没有查询到则返回登录失败结果
4. 密码比对，如果不一致则返回登录失败结果
5. 查看员工状态，如果为已禁用状态，则返回员工已禁用结果
6. 登录成功，将员工`id`存入`Session`并返回登录成功结果

![image-20230427105348146](assets/image-20230427105348146.png)

### 4.3 功能测试

测啊测，测测测...

## 5 后台退出功能开发

- 用户点击页面中退出按钮，发送请求，请求地址为`/employee/logout`，请求方式为POST
- 我们只需要在`Controller`中创建对应的处理方法即可，具体的处理逻辑
  - 清理`Session`中的用户`id`
  - 返回结果

# day 02

## 1 完善登录功能

### 1.1 需求分析

前面我们已经完成了后台系统的员工登录功能开发，但是还存在一个问题：用户如果不登录，直接访问系统首页面，照样可以正常访问。这种设计并不合理，我们希望看到的效果应该是，只有登录成功后才可以访问系统中的页面，如果没有登录则跳转到登录页面。

那么，具体应该怎么实现呢？答案就是使用过滤器或者拦截器，在过滤器或者拦截器中判断用户是否已经完成登录，如果没有登录则跳转到登录页面，

### 1.2 代码实现

1. 创建自定义过滤器`LoginCheckFilter`
2. 在启动类上加入注解`@ServletComponentScan`
3. 完善过滤器的处理逻辑

过滤器具体的处理逻辑如下：

1. 获取本次请求的 URL
2. 判断本次请求是否需要处理
3. 如果不需要处理，则直接放行
4. 判断登录状态，如果已登录，则直接放行
5. 如果未登录则返回未登录结果

![image-20230503115602088](assets/image-20230503115602088.png)

```java
package com.itheima.reggie.filter;

import com.alibaba.fastjson.JSON;
import com.itheima.reggie.common.Result;
import lombok.extern.slf4j.Slf4j;
import org.springframework.util.AntPathMatcher;

import javax.servlet.*;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * 检查用户是否完成登录
 */
@Slf4j
@WebFilter(filterName = "loginCheckFilter", urlPatterns = "/*")
public class LoginCheckFilter implements Filter {

    // 路径匹配器 支持通配符
    public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher();

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        HttpServletResponse response = (HttpServletResponse) servletResponse;

        // 1. 获取本次请求的 URL
        String requestURI = request.getRequestURI();
        log.info("拦截到请求：{}", requestURI);

        // 2. 判断本次请求是否需要处理
        // 定义不需要处理的请求路径
        String[] urls = new String[]{
                "/employee/login",
                "/employee/logout",
                "/backend/**",
                "/front/**",
        };
        boolean check = check(urls, requestURI);

        // 3. 如果不需要处理，则直接放行
        if (check) {
            log.info("本次请求不需要处理：{}", requestURI);
            filterChain.doFilter(request, response);
            return;
        }

        // 4. 判断登录状态，如果已登录，则直接放行
        Object attribute = request.getSession().getAttribute("employee");
        // log.info("\n\n\n{}\n\n\n{}\n\n\n", attribute, attribute.toString());
        if (attribute != null) {
            log.info("用户已登录，用户 id 为 {}", attribute);

            filterChain.doFilter(request, response);
            return;
        }

        // 5. 如果未登录则返回未登录结果
        response.getWriter().write(JSON.toJSONString(Result.error("NOTLOGIN")));
        log.info("用户未登录");
        return;
    }

    /**
     * 路径匹配 判断本次请求是否需要放行
     * @param urls
     * @param requestURI
     * @return true: 放行 false: 需要校验是否登录
     */
    public boolean check(String[] urls, String requestURI) {
        for (String url : urls) {
            boolean match = PATH_MATCHER.match(url, requestURI);
            if (match) {
                return true;
            }
        }
        return false;
    }
}
```

## 2 新增员工

### 2.1 需求分析

1. 页面发送`ajax`请求，将新增员工页面中输入的数据以`json`的形式提交到服务端
2. 服务端`Controller`接收页面提交的数据并调用`Service`将数据进行保存
3. `Service`调用`Mapper`操作数据库，保存数据

前面的程序还存在一个问题，就是当我们在新增员工时输入的账号已经存在，由于`emplovee`表中对该字段加入了唯一约束，此时程序会抛出异常：

```java
java.sql.SQLIntegrityConstraintViolationException: Duplicate entry 'fafa' for key 'employee.idx_username'
```

### 2.2 代码实现

```java
/**
 * 新增员工
 * @param employee
 * @return
 */
@PostMapping
public Result<String> save(@RequestBody Employee employee, HttpServletRequest request) {
    log.info("新增员工，员工信息：{}", employee);

    // 初始密码
    employee.setPassword(DigestUtils.md5DigestAsHex("123456".getBytes()));
    employee.setCreateTime(LocalDateTime.now());
    employee.setUpdateTime(LocalDateTime.now());
    employee.setCreateUser((Long) request.getSession().getAttribute("employee"));
    employee.setUpdateUser((Long) request.getSession().getAttribute("employee"));

    employeeService.save(employee);

    return Result.success("添加成功");
}
```

### 2.3 全局异常处理器

```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.*;

import java.sql.SQLIntegrityConstraintViolationException;

/**
 * 全局异常处理器
 */
@ControllerAdvice(annotations = {RestController.class, Controller.class})  // 捕获加了这些注解的类所抛出的异常
@ResponseBody
@Slf4j
public class GlobalExceptionHandle {

    /**
     * 异常处理方法 该方法处理的是 sql 的 SQLIntegrityConstraintViolationException 异常
     * @return
     */
    @ExceptionHandler(java.sql.SQLIntegrityConstraintViolationException.class)
    public Result<String> exceptHandler(SQLIntegrityConstraintViolationException ex) {
        String exMessage = ex.getMessage();

        // 判断是不是 username 重复的异常
        if (exMessage.contains("Duplicate entry")) {
            String[] split = exMessage.split(" ");
            String errorMsg = "用户名" + split[2] + "已经存在了...";
            return Result.error(errorMsg);
        }

        return Result.error("未知错误...");
    }
}
```

## 3 员工信息分页查询

### 3.1 需求分析

系统中的员工很多的时候，如果在一个页面中全部展示出来会显得比较乱，不便于查看，所以一般的系统中都会以分页的方式来展示列表数据。

1. 页面发送`ajax`请求，将分页查询参数（`page`、`pageSize`、`name`）提交到服务端
2. 服务端`Controller`接收页面提交的数据并调用`Service`查询数据
3. `Service`调用`Mapper`操作数据库，查询分页数据
4. `Controller`将查询到的分页数据响应给页面
5. 页面接收到分页数据并通过`Elementul`的`Table`组件展示到页面上

### 3.2 代码实现































